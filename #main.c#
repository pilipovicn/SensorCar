//main.c
#include "init.h"
#include "uart.h"
#include <math.h>

// ******************************************************************************************* //
// Configuration bits for CONFIG1 settings. 
//
// Make sure "Configuration Bits set in code." option is checked in MPLAB.
// This option can be set by selecting "Configuration Bits..." under the Configure
// menu in MPLAB.

_FOSC(CSW_FSCM_OFF & XT_PLL4);
_FWDT(WDT_OFF);

//IC1 interrupt flag
volatile char falling_edge_rcvd;
volatile char falling_edge_rcvd2;
int interrupt_count = 0;
int i,j;
int sensor=0;

//rising & falling flag
volatile char rising_edge;
volatile unsigned int rising_time, falling_time;
volatile char rising_edge2;
volatile unsigned int rising_time2, falling_time2;

//flag to start new frame
volatile char new_frame_start = 0;

//value to hold number of timer counts of echo
//Timer2 count, with presclaer @ 1:8, is 2E-7s -or-
//5 counts per 1us
volatile unsigned int timer_counts;
volatile unsigned int timer_counts2;

//echo period in us
//= timer_counts / 5.0 to convert to us
volatile float period_us;

//distance variable. units are cm
volatile int distance = 10;
volatile int distance2 = 10;
char dist[10];

#define FORWARD_MOVE()({OC1RS = 2000; LATFbits.LATF0 = 1; LATBbits.LATB12 = 0; LATBbits.LATB9 = 0; LATBbits.LATB10 = 1;})
#define BACKWARD_MOVE()({OC1RS = 2000; LATFbits.LATF0 = 0; LATBbits.LATB12 = 1; LATBbits.LATB9 = 1; LATBbits.LATB10 = 0;})
#define STOP_MOVE()({LATFbits.LATF0 = 0; LATBbits.LATB12 = 0; LATBbits.LATB9 = 0; LATBbits.LATB10 = 0;})
#define RIGHT_TURN()({LATFbits.LATF0 = 0; LATBbits.LATB12 = 1; LATBbits.LATB9 = 0; LATBbits.LATB10 = 1;})
#define LEFT_TURN()({LATFbits.LATF0 = 1; LATBbits.LATB12 = 0; LATBbits.LATB9 = 1; LATBbits.LATB10 = 0;})
#define STOP_TURN()({LATBbits.LATB9 = 0; LATBbits.LATB10 = 0;})

void rough_delay(){
    for(i=0; i<1000; i++)
        for(j=0; j<600; j++);
}

void rough_delay2(){
    for(i=0; i<1000; i++)
        for(j=0; j<600; j++);
}

void corner_delay(){
    for(i=0; i<4000; i++)
        for(j=0; j<4000; j++);
}

int main()
{
    init_pins();
    LATDbits.LATD0 = 1;
    
    //initialize everything
    falling_edge_rcvd = 0;
    falling_edge_rcvd2 = 0;
    new_frame_start = 0;
    rising_edge = 1;
    rising_edge2 = 1;

    //initializations
    InitHC_SR04();
    //InitClock();
    InitUART1();
    InitTimer1();
    InitTimer2();
    InitTimer3();

    //wait for signal from PC
    RS232_putst("Pocetak!\n");
    STOP_MOVE();
    rough_delay();
    while(1) {

        //refresh everything
        //new_frame_start = 0;

        //clear timer counter and start it up again
        //TMR1 = 0;
        //T1CONbits.TON = 1;

        //Set Trigger pin high for ~10us (a bit more here)
        LATDbits.LATD3 = 1;
        LATDbits.LATD2 = 1;
        //while (TMR1 < 10);
        for(i=0; i<800; i++);
        LATDbits.LATD3 = 0;
        LATDbits.LATD2 = 0;

        //wait for timer1 to interrupt indicating new frame
        //do all the calcuations after this
        //while(new_frame_start == 0);
        
        for(i=0; i<80; i++)
            for(j=0; j<80; j++);
        //means echo has gone low and interrupt occurred
        if(falling_edge_rcvd == 1) {

            //logic for rollover of timer2
            if (falling_time > rising_time) {
                timer_counts = falling_time - rising_time;
            }
            else {
                //PR2 resets to 0xFFFF
                //timer_counts = (PR2 - rising_time) + falling_time;
                continue;
            }
            //period_us = (timer_counts / 10);
            //distance = period_us / 58.0; /
            distance = timer_counts / 580.0;
            
        }
        else {
            //distance = -1.0;
            ;;
        }
        if(falling_edge_rcvd2 == 1) {

            //logic for rollover of timer2
            if (falling_time2 > rising_time2) {
                timer_counts2 = falling_time2 - rising_time2;
            }
            else {
                //PR2 resets to 0xFFFF
                //timer_counts = (PR2 - rising_time) + falling_time;
                continue;
            }
            //period_us = (timer_counts / 10);
            //distance = period_us / 58.0; /
            distance2 = timer_counts2 / 580.0;
            
        }
        else {
            //distance = -1.0;
            ;;
        }

        //reset the flag for the next frame
        falling_edge_rcvd = 0;
        falling_edge_rcvd2 = 0;

        sprintf(dist, "D1:%d | D2:%d", distance, distance2);
        
        if(distance2 > 29){
            if(distance > 21){
                RS232_putst("Blago desno!");
                RIGHT_TURN();
                rough_delay();
                FORWARD_MOVE();
                rough_delay2();
            }else{
                RS232_putst("Skrecem desno!");
                RIGHT_TURN();
                corner_delay();
            }
        }else if(distance2 < 17){
            if(distance > 21){
                RS232_putst("Blago levo!");
                LEFT_TURN();
                rough_delay();
                FORWARD_MOVE();
                rough_delay2();
            }else{
                RS232_putst("Skrecem levo!");
                LEFT_TURN();
                corner_delay();
            }
        }else{
            if(distance > 21){
                RS232_putst("Idem pravo!");
                FORWARD_MOVE();
            }else{
                if(distance2 > 31){
                    RS232_putst("Skrecem desno!");
                    RIGHT_TURN();
                    corner_delay();
                }else{
                    LEFT_TURN();
                    RS232_putst("Skrecem levo!");
                    corner_delay();
                }
            }
        }
        
        
        RS232_putst(dist);
   
        //for(i=0; i<1000; i++)
        //    for(j=0; j<1400; j++);
    }

    return 1;
}

void __attribute__((__interrupt__, no_auto_psv)) _U1RXInterrupt(void)
{

	// Clear interrupt flag
	IFS0bits.U1RXIF = 0;
    //let the main loop know we received a char
    //uart_rcvd = 1;
    //load the char
    //uart_rcvd_char = U1RXREG;
}

void __attribute__((__interrupt__, no_auto_psv)) _IC1Interrupt(void)
{

    unsigned int t1;
    t1 = IC1BUF;
    //Clear IF
    IFS0bits.IC1IF = 0;
    if (rising_edge == 1) {
        rising_time = t1;
        rising_edge = 0;
    }
    else {
        falling_edge_rcvd = 1;
        falling_time = t1;
        rising_edge = 1;
        
        
    }

}

void __attribute__((__interrupt__, no_auto_psv)) _IC2Interrupt(void)
{

    unsigned int t2;
    t2 = IC2BUF;
    //Clear IF
    IFS0bits.IC2IF = 0;
    if (rising_edge2 == 1) {
        rising_time2 = t2;
        rising_edge2 = 0;
    }
    else {
        falling_edge_rcvd2 = 1;
        falling_time2 = t2;
        rising_edge2 = 1;
        
        
    }

}

void __attribute__((__interrupt__, no_auto_psv)) _T1Interrupt(void)
{

	// Clear Timer 1 interrupt flag to allow another Timer 1 interrupt to occur.
	IFS0bits.T1IF = 0;
    T1CONbits.TON = 0;
    new_frame_start = 1;
    interrupt_count++;
}


void __attribute__((__interrupt__)) _T2Interrupt(void){
   	TMR2 = 0;
    IFS0bits.T2IF = 0;
}